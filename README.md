# Android 面试题整理

## 一、JVM

[JVM底层原理最全知识总结](https://doocs.github.io/jvm/)

### 1. GC Root 有哪些？

- 虚拟机栈中引用的对象：

  如下代码所示，a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 **GC Root** 的作用，a 与原来指向的实例 **new Test()** 断开了连接，所以对象会被回收。

  ```java
  public class Test {
      public static void main(String[] args) {
  		  Test a = new Test();
  		  a = null;
      }
  }
  ```

- 方法区中类静态属性引用的对象：

  如下代码所示，当栈帧中的本地变量 a = null 时，由于 a 原来指向的对象与 GC Root (变量 a) 断开了连接，所以 a 原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s 在此时是类静态属性引用，充当了 GC Root 的作用，它指向的对象依然存活。

  ```java
  public class Test {
      public static Test s;
      public static  void main(String[] args) {
  		  Test a = new Test();
  		  a.s = new Test();
  		  a = null;
      }
  }
  ```

- 方法区中常量引用的对象

  如下代码所示，常量 s 指向的对象并不会因为 a 指向的对象被回收而回收

  ```java
  public class Test {
  	public static final Test s = new Test();
      public static void main(String[] args) {
  		  Test a = new Test();
  		  a = null;
      }
  }
  ```

- 本地方法栈中 JNI 引用的对象

  比如 java 调用 C++ 的方法这些。

### 2. JVM 内存模型

分为五个部分，程序计数器，Java 虚拟机栈，本地方法栈，堆，方法区。

- 程序计数器：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每个线程都有独立的程序计数器，用来在线程切换后能恢复到正确的执行位置。各线程之间的计数器互不影响，独立存储。线程私有。
- 虚拟机栈：线程私有的一块内存区域，它描述的是 java 方法执行的内存模型，每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程都对应这一个栈帧从入栈到出栈的过程。每当一个方法执行完毕时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧。Java 栈的栈顶的栈帧就是当前执行的方法。方法的调用过程也是由栈帧切换来产生结果。
- 本地方法栈：本地方法栈为虚拟机使用到的Native方法服务，涉及到 JNI。
- 堆：Heap是OOM故障最主要的发源地，它存储着几乎所有的实例对象，堆由垃圾收集器自动回收，堆区由各子线程共享使用；通常情况下，它占用的空间是所有内存区域中最大的，但如果无节制地创建大量对象，也容易消耗完所有的空间。
- 方法区：方法区是被所有线程共享的内存区域，用来存储已被虚拟机加载的类信息、常量、静态变量、JIT（just in time，即时编译技术）编译后的代码等数据。运行时常量池是方法区的一部分，用于存放编译期间生成的各种字面常量和符号引用。

![内存模型](https://upload-images.jianshu.io/upload_images/10006199-a4108d8fb7810a71.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

### 3. 垃圾回收策略及算法

### 4. 类加载机制

[学习来源](https://juejin.cn/post/6865572557329072141)

类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载，验证，准备，解析，初始化，使用，卸载。**验证、准备、解析**统称为连接。

![类生命周期](https://tva1.sinaimg.cn/large/007S8ZIlly1gi5eqpkg4cj312m0dyjvn.jpg)

- 加载：查找并加载类的二进制数据，通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为**方法区**的运行时数据结构。在内存（**堆**）中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。

![类加载](https://tva1.sinaimg.cn/large/007S8ZIlly1gi57jiyydxj30ya0icdiw.jpg)

- 验证：验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。主要有四个检验动作。

  - 文件格式验证：验证字节流是否符合 Class 文件格式的规范。
  - 元数据验证：对字节码描述的信息进行语义分析（比如说看看这个类有没有父类）
  - 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的
  - 符号引用验证：确保解析动作能正确执行

  验证阶段是很重要的，但不是必须的。可以考虑关闭一些类验证措施，以缩短虚拟机类加载时间。

- 准备：为类的**静态变量**（不包括实例变量）分配内存，并将其初始化为默认值。

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。（**其他详情请看原文章**）

- 解析：把类中的符号引用转换为直接引用

  **解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**，解析动作主要针对`类`或`接口`、`字段`、`类方法`、`接口方法`、`方法类型`、`方法句柄`和`调用点`限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。

  `直接引用`就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

  [不懂的来这篇文章](https://cana.space/%E8%AF%A6%E8%A7%A3%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8%E8%BD%AC%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8/)

- 初始化：对类的静态变量，静态代码块执行初始化操作

  初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。

  **类初始化**：

  - 假如这个类还没有被加载和连接，则程序会先加载并连接该类
  - 假如该类的直接父类还没有被初始化，则先初始化其直接父类
  - 假如类中有初始化语句，则系统依次执行这些初始化语句

  **类初始化时机**：当对类主动使用的时候

  - 使用 new 关键字实例化对象
  - 调用一个类的静态方法
  - 当初始化该类时，如果其父类没有被初始化，则需要先触发其父类的初始化
  - 使用反射进行调用时，如果类型还没有被初始化，则需要先触发其初始化
  - 读取或设置一个类型的静态字段的时候

- 使用：类访问方法区内的数据结构和接口，对象是 Heap 区的数据

- 卸载：Java 虚拟机将结束生命周期的几种情况

  - 执行了 System.exit() 方法
  - 程序正常执行结束
  - 程序在执行过程中遇到了异常或错误而异常终止
  - 由于操作系统出现错误而导致 Java 虚拟机进程终止

### 5. 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器”。

![类加载器的层次](https://tva1.sinaimg.cn/large/007S8ZIlly1gi5f30yg36j30vx0u0n9z.jpg)

双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

- 启动类加载器：这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。
- 扩展类加载器：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器：它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

JVM 类加载特点：

- 全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。
- 缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。
- 双亲委派机制：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

## 二、Java基础

### 1. synchronized 给普通方法，静态方法以及代码块加锁的区别？

- 给类中的普通方法加锁，属于对象锁，锁的是当前对象，即同一个对象可以同步访问。但是创建了两个对象对同步方法进行访问，则不能保持同步。
- 给类中的静态方法加锁，属于类锁，作用域是整个类。即使是两个不同的对象对同步方法进行访问也可以保持同步。
- 给类中的方法块加锁，这其中也分为对象锁和类锁，和上面的区别差不多。类锁的形式是

```java
synchronized(A.class) {
    ...
}
```

所有对象都可以保持同步。对象锁的形式是

```java
synchronized(this) {
    ...
}
```

对于同一个对象可以保持同步，但不同对象不能同步。

### 2. synchronized 和 volatile 的区别

[锁原理](https://segmentfault.com/a/1190000023315634)

https://zhuanlan.zhihu.com/p/55167585

### 3. 面向对象七大原则

- 单一职责原则：即一个类只负责一个功能，核心就是解耦和增强内聚性。
- 里氏替换原则：即子类不可以重写父类方法的功能，如果要增加新功能，可以新建一个方法。
- 开闭原则：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
- 合成/复合原则：要尽量使用组合，尽量不要使用继承。
- 接口分离原则：每一个接口的职责单一明确，所以当我们要实现一个复杂的类时，尽量去实现多个接口，而不要把多个接口的功能放到一个接口。
- 依赖倒置原则：程序要依赖于抽象接口，不要依赖于具体实现。
- 迪米特（最少知道）原则：一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解。

### 4. 面向对象三大特性

https://zhuanlan.zhihu.com/p/27912079

## 三、计算机网络

### 1. OSI七层模型分别是什么？各自的功能是什么？

- 物理层：实现的是底层的数据传输，通过物理介质传送比特流。使得上层不必关心是通过什么介质传输的。
- 数据链路层：定义数据的基本格式，将比特组合成字节，再将字节组合成帧。使用链路层地址（MAC）来访问介质，并进行差错检测
- 网络层：通过IP寻址来建立两个结点之间的连接，为传输层的分组选择合适的路由和交换结点。主要的协议是IP协议。
- 传输层：建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。主要的协议有TCP/UDP协议。
- 会话层：负责建立、管理和终止表示层实体之间的通信会话。
- 表示层：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。例如数据的压缩与解压缩，加密与解密等。
- 应用层：为计算机用户提供应用接口，也为用户直接提供各种网络服务。比如说HTTP、SMTP、FTP等是应用层的协议。

[OSI七层模型详细讲解点击这](https://www.cnblogs.com/sunweiye/p/11083601.html)

### 2. TCP和UDP的区别？各自有什么应用场景？

- TCP提供可靠的传输，UDP不提供可靠的传输，它会尽最大努力提供交付。
- TCP是面向连接的，UDP是无连接的。
- TCP传输数据具有有序性，而UDP不保证数据的有序。
- TCP的传输速度相对于UDP较慢。
- TCP有流量控制和拥塞控制，UDP则没有。
- TCP是重量级协议，UDP是轻量级协议。
- TCP连接只能有两个端点，即TCP是端到端的。而UDP可以是一对一，一对多，多对多的。
- TCP是面向字节流传输的，不保存数据的边界。UDP则是面向报文传输的，保存数据的边界。



- TCP的应用场景应是效率需求低，但是对准确性要求高。比如说文件的传输，邮件的传输，支付等。
- UDP的应用场景则是对效率要求高，对准确性要求不高。比如说即时通讯，在线视频等。

### 3. 为什么要三次握手？两次不行吗？

- 第一次握手：客户端给服务端发送一个SYN报文，指明客户端初始化序列号ISN，此时客户端处于 **SYN_SENT** 状态。服务端收到了，那么服务端就可以确定**客户端的发送能力**是正常的。
- 第二次握手：服务端收到了，给客户端发送一个自己的SYN报文作为应答，并指明自己的初始化序列号，同时把客户端的 ISN + 1 作为 ACK 的值，表示自己收到了客户端的 SYN，此时服务端处于 **SYN_RCVD** 状态。客户端收到了，就可以确定**服务端的发送能力**和**接收能力**是正常的，但是服务端还不能确定客户端的接收能力是否正常。
- 第三次握手：客户端收到 SYN 报文后，向服务端发送 ACK 报文，也是将服务端的 ISN + 1 作为 ACK 的值。表示已经收到服务端的 SYN 报文。服务端收到了，就可以确定**客户端的接收能力**是正常的，此时双方都处于 **established** 状态。

综上所述，只有三次握手双方才能确定对方的发送能力和接收能力是正常的。

ps：第三次握手是可以携带数据发送的，因为客户端此时已经可以确定服务端的发送能力和接收能力是正常的了。

![三次握手](https://img-blog.csdnimg.cn/2020082716294932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODY4NDI3NA==,size_16,color_FFFFFF,t_70#pic_center)

### 4. 为什么要四次挥手？三次不行吗？

- 第一次挥手：客户端发起断开连接请求，向服务端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 **FIN_WAIT1** 状态。
- 第二次挥手：服务端收到客户端发送的 FIN 报文后，会发送一个 ACK 报文，把客户端的序列号 + 1 作为其值。表示收到客户端的报文了，此时，服务端处于 **CLOSE_WAIT** 状态。
- 第三次挥手：如果服务端也想关闭连接了，也会向客户端发送一个 FIN 报文，且指定一个序列号。此时服务端处于 **LAST_ACK** 状态。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 **TIME_WAIT** 状态。**需要过一阵子**以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态。

为什么要等一阵子（2MSL）客户端才进入 CLOSED 状态呢？因为它要确保服务端收到了自己的 ACK 报文，如果服务端没收到，会重新发送一个 FIN 报文请求断开连接。

![四次挥手](https://img2018.cnblogs.com/blog/1535576/201910/1535576-20191012001944770-1619591507.png)

### 5. HTTP 和 HTTPS 的区别？

HTTPS 协议一般理解为 HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

HTTPS 在应用层和传输层之间又建立了一个安全层，在这个安全通道中进行数据的传输。在传输过程中，会对数据进行加密处理。保证数据的完整性，保密性。并且浏览器还会对服务器进行一个源端鉴别，确保目标地址的安全性。

HTTPS的端口是443，而HTTP的端口是80。

HTTPS也有缺点，其多次握手，导致页面的加载时间延长近50%；HTTPS的连接缓存不如HTTP高效，会增加数据的开销与消耗。且向CA申请证书需要钱，功能越强，花费越大。



>HTTPS 采用混合加密机制，即非对称加密（公开秘钥加密，公钥加密，私钥解密）和对称加密（共享秘钥加密，私钥加密解密）一起使用。在交换秘钥环节，客户端向服务端发送用**公开秘钥的公钥加密**的**共享秘钥的私钥**，服务端收到之后，用公开密钥加密的私钥解密，得到**共享秘钥的私钥**。之后，双方就可以用共享秘钥加解密来进行通信了。

### 6. TCP 协议是如何保证数据可靠传输的？

- 数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据。
- 对失序数据包重排序：TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层。
- 丢弃重复数据：对于重复数据，能够丢弃重复数据。
- 应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。
- 超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
- 流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。

### 7. 谈谈你对滑动窗口的理解

TCP 通过滑动窗口机制实现流量控制，早期的网络通信过程中，由于没有对网络通信的拥挤情况进行控制，通信双方不知道网络拥塞情况。当网络发生拥塞时，还在传输数据，就会发生丢包现象。所以就有了滑动窗口来解决拥塞问题。

TCP 通过滑动窗口来实现传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用来接收数据，发送方可以根据滑动窗口的大小来确定可以发送多少字节的数据。如果接收方的滑动窗口大小为0，发送方就不能再发送数据了。这样就可以有效避免发生网络拥塞问题。

### 8. 谈谈你对 TCP 拥塞控制的理解？用到了什么算法？

拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不至于过载。拥塞控制所要做的都有一个前提，就是网络能够承载现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。

而流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是抑制发送端发送数据的速率，一遍接收端来得及接收。

为了进行拥塞控制，TCP 发送方需要维持一个拥塞窗口的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且是动态变化的。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口的最小值。

TCP 拥塞控制采用了四种算法。即：慢开始、拥塞避免、快重传和快恢复。

- **慢开始**：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据注入网络中，那么就可能会引起网络阻塞，因为现在还不知道网络的负荷情况。所以最好的办法是先探测一下，然后再逐步增大发送窗口。
- **拥塞避免**：拥塞避免的思路是让拥塞窗口缓慢增大，每经过一个往返时间 RTT 就把发送方的拥塞窗口 + 1。
- **快重传**：在 TCP 传输过程中，如果发生了丢包，接收端就会重复发送之前的 ACK。比如第5个包丢了，6，7到达了。那么接收端会为5,6,7都发送第4个包的ACK，这个时候发送端收到了3个相同的 ACK ，就会意识到丢包了，就会马上进行重传，而不用等到 RTO（超时重传时间）。
- **快恢复**：如果发送端收到了3个重复的 ACK，发生了丢包，觉得现在的网络状况已经进入了拥塞状态了，那么就会进入快速恢复阶段。
  - 会将拥塞阈值降低为拥塞窗口的一半
  - 拥塞窗口的大小变为拥塞阈值
  - 然后拥塞窗口在线性增加，来适应网络情况。

### 9. UDP 如何实现可靠传输？

- 添加 seq / ack 机制，确保数据发送到了接收端

- 添加发送和接收缓冲区，用于超时重传。

  ps：需要在应用层实现

### 10. HTTP/1.0，HTTP/1.1，HTTP/2.0 有什么区别？

- **HTTP/1.0**：其规定浏览器和服务器之间只能保持短暂的连接，浏览器每次请求都需要与服务器建立一个TCP连接，服务器完成请求后立即断开连接。而每次建立连接都需要三次挥手，比较耗费时间，所以 HTTP/1.0 的性能很差。
- **HTTP/1.1**：最主要的改进就是引入了持久连接。即 TCP 连接默认不关闭，可以被多个请求复用。但是服务端还是按顺序执行。
- **HTTP/2.0**：其采用了多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应。可以这样做的原因是：HTTP/2.0 进行了二进制分帧，即 HTTP/2.0 会将所有传输的信息分割为更小的消息和帧，并对他们进行二进制格式的编码。除此之外，还对 header 进行了压缩，使性能进一步提升。

### 11. DNS 解析过程

主机向本地域名服务器的查询一般都是采用**递归查询**。如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。

本地域名服务器向根域名服务器的查询的迭代查询。当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。**根域名服务器**通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。**顶级域名服务器**在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个**权限域名服务器**进行查询。

### 12. 在浏览器中输入 URL 地址到显示主页的过程？

- DNS 解析
- TCP 连接 三次握手
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器渲染解析界面
- 断开连接 四次挥手

## 四、设计模式

### 1. 单例模式（通常需要手撕，所以重点讲述）

使用单例模式就可以避免一个全局使用的类，频繁的创建与销毁，耗费系统资源。

[学习来源](https://segmentfault.com/a/1190000039746895)

#### 1. 懒汉式

```java
public class Singleton {
    private static Singleton uniqueInstance;
    
    private Sinleton() {}
    
    public static Singleton getInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        
        return uniqueInstance;
    }
}
```

**说明：** 先不创建实例，当第一次被调用时，再创建实例，所以被称为懒汉式。

**优点：** 延迟了实例化，如果不需要使用该类，就不会被实例化，节约了系统资源。

**缺点：** 线程不安全，多线程环境下，如果多个线程同时进入了 if (uniqueInstance == null) ，若此时还未实例化，也就是uniqueInstance == null，那么就会有多个线程执行 uniqueInstance = new Singleton(); ，就会实例化多个实例；

#### 2. 饿汉式 （线程安全）

```java
public class Singleton {
    private static Singleton uniqueInstance = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return uniqueInstance;
    }
}
```

**说明：** 先不管需不需要使用这个实例，直接先实例化好实例 (饿死鬼一样，所以称为饿汉式)，然后当需要使用的时候，直接调方法就可以使用了。

**优点：** 提前实例化好了一个实例，避免了线程不安全问题的出现。

**缺点：** 直接实例化好了实例，不再延迟实例化；若系统没有使用这个实例，或者系统运行很久之后才需要使用这个实例，都会操作系统的资源浪费。

#### 3. 懒汉式（线程安全）

```java
public class Singleton {
    private static Singleton uniqueInstance;
    
    private Singleton() {}
    
    public static synchronized Singleton getInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        
        return uniqueInstance;
    }
}
```

**说明：** 实现和线程不安全的懒汉式 几乎一样，唯一不同的点是，在get方法上加了一把锁。如此一来，多个线程访问，每次只有拿到锁的的线程能够进入该方法，避免了多线程不安全问题的出现。

**优点：** 延迟实例化，节约了资源，并且是线程安全的。

**缺点：** 虽然解决了线程安全问题，但是性能降低了。因为，即使实例已经实例化了，既后续不会再出现线程安全问题了，但是锁还在，每次还是只能拿到锁的线程进入该方法，会使线程阻塞，等待时间过长。

#### 4. 双重校验锁（线程安全）

```java
public class Singleton {
    private static volatile Singleton uniqueInstance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        
        return uniqueInstance;
    }
}
```

**说明:** 双重检查数相当于是改进了线程安全的懒汉式。线程安全的懒汉式的缺点是性能降低了，造成的原因是因为即使实例已经实例化，依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。 也就是，先判断实例是否已经存在，若已经存在了，则不会执行判断方法内的有锁方法了。 而如果，还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候，会有线程阻塞的情况，后续便不会再有线程阻塞的问题。

**优点：** 延迟实例化，节约了资源；线程安全；并且相对于 线程安全的懒汉式，性能提高了。

**缺点：** volatile 关键字，对性能也有一些影响。

#### 5. 静态内部类实现（线程安全）

```java
public class Singleton {
    private Singleton() {}
    
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**说明：** 首先，当外部类 Singleton 被加载时，静态内部类 SingletonHolder 并没有被加载进内存。当调用 getUniqueInstance() 方法时，会运行 return SingletonHolder.INSTANCE; ，触发了 SingletonHolder.INSTANCE ，此时静态内部类 SingletonHolder 才会被加载进内存，并且初始化 INSTANCE 实例，而且 JVM 会确保 INSTANCE 只被实例化一次。

**优点：** 延迟实例化，节约了资源；**且线程安全**，因为取得都是同一个 INSTANCE 实例；性能也提高了。

#### 6. 枚举类实现

```java
public enum Singleton {
    
    INSTANCE;

    //添加自己需要的操作
    public void doSomeThing() {
    
    }
}
```

**说明：** 默认枚举实例的创建就是线程安全的，且在任何情况下都是单例。

**优点：** 写法简单，线程安全，天然防止反射和反序列化调用。

### 2. 其他设计模式

[详情请看这篇文章，讲得很细](https://juejin.cn/post/6844903638503161870)

ps：我认为代理模式不是很好理解，所以专门看了很多博文才弄懂，下面这篇是我认为比较好理解的。还有，都具体学习代理模式了，建议去看一下AOP编程思想。

[代理模式详解](https://www.zhihu.com/question/20794107)

[Retrofit中的动态代理](
